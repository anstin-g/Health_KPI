<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Generator</title>
    <link rel="stylesheet" href="/static/analyze_Kpi.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        /* Additional styles for the checkbox cards */
        .checkbox-cards-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            margin-top: 10px;
            background-color: #f9f9f9;
        }
        
        .metric-card {
            position: relative;
            padding: 10px 15px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            font-size: 14px;
            display: flex;
            align-items: center;
        }
        
        .metric-card:hover {
            border-color: #4CAF50;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .metric-card.selected {
            background-color: #eef2ff;
            border-color: #45a049;
            box-shadow: 0 2px 5px rgba(67, 97, 238, 0.2);
        }
        
        .metric-card input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .metric-card label {
            cursor: pointer;
        }
        
        .selected-count {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
        }
        
        .selected-count.warning {
            color: #dc3545;
            font-weight: bold;
        }

        /* Hide the original dropdown */
        .dropdown-container {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Health Metrics Graph Generator</h1>

        <input type="hidden" id="selectedFiles" name="selected_files" value="{{ selected_files|join:',' }}">
        <input type="hidden" id="availableKpis" value="{{ sorted_list_of_kpis|join:',' }}">

        <div class="selection-container">
            <div class="search-box">
                <div class="search-icon">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                </div>
                <input type="text" id="searchBox" placeholder="Search for metrics...">
            </div>
            
            <!-- Original dropdown (hidden but kept for compatibility) -->
            <div class="dropdown-container">
                <label for="dropdown" class="dropdown-label">Select up to 5 health metrics:</label>
                <select id="dropdown" multiple>
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            
            <!-- New checkbox cards container -->
            <div>
                <label class="dropdown-label">Select up to 5 health metrics:</label>
                <div id="checkboxCardsContainer" class="checkbox-cards-container">
                    <!-- Metric cards will be populated by JavaScript -->
                </div>
                <div id="selectedCount" class="selected-count">Selected: 0/5</div>
            </div>
            
            <div class="selected-options" id="selectedOptions">
                <!-- Selected tags will appear here -->
            </div>
        </div>
        
        <button id="generateBtn" disabled>Generate Graphs</button>
        
        <!-- Update the loader HTML to explicitly add the hidden class -->
<div id="loader" class="hidden">
    <div class="loader-spinner"></div>
    <span>Generating Graph... Please wait, it may take a while </span>
</div>
        
        <div id="graphsContainer"></div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const dropdown = document.getElementById("dropdown");
            const searchBox = document.getElementById("searchBox");
            const generateBtn = document.getElementById("generateBtn");
            const loader = document.getElementById("loader");
            const graphsContainer = document.getElementById("graphsContainer");
            const selectedOptionsContainer = document.getElementById("selectedOptions");
            const checkboxCardsContainer = document.getElementById("checkboxCardsContainer");
            const selectedCountDisplay = document.getElementById("selectedCount");
            
            // Force hide the loader when the page loads
    loader.style.display = "none";
    loader.classList.add("hidden");
            
            let chartInstances = [];
            let selectedValues = [];
            
            // Get available KPIs from the hidden input
            const availableKpisInput = document.getElementById("availableKpis");
            const options = availableKpisInput.value ? availableKpisInput.value.split(',') : [];
            
            // Initialize checkbox cards
            populateCheckboxCards(options);
            
            // Search functionality
            searchBox.addEventListener("input", function() {
                const searchTerm = this.value.toLowerCase();
                const filteredOptions = options.filter(option => 
                    option.toLowerCase().includes(searchTerm)
                );
                populateCheckboxCards(filteredOptions);
            });
            
            // Handle generate button click
            generateBtn.addEventListener("click", function() {
                let selectedFiles = document.getElementById("selectedFiles").value;
                
                loader.classList.remove("hidden");
                loader.style.display = "flex";
                
                // Clear previous charts
                chartInstances.forEach(chart => chart.destroy());
                chartInstances = [];
                graphsContainer.innerHTML = "";

                fetch('/analyse_kpi/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify({
                        selected_values: selectedValues,
                        selected_files: selectedFiles
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    loader.classList.add("hidden");
                    loader.style.display = "none";
                    console.log("Received chart data:", data);
                    
                    if (!data.chart_data || Object.keys(data.chart_data).length === 0) {
                        graphsContainer.innerHTML = "<p class='text-center'>No data available for selected metrics.</p>";
                        return;
                    }

                    Object.entries(data.chart_data).forEach(([key, chartData]) => {
                        const chartContainer = document.createElement("div");
                        chartContainer.className = "chart-wrapper";
                        
                        const title = document.createElement("h3");
                        title.textContent = key;
                        chartContainer.appendChild(title);
                        
                        const canvas = document.createElement("canvas");
                        chartContainer.appendChild(canvas);
                        graphsContainer.appendChild(chartContainer);
                        
                        const labels = chartData.map(item => item.name);
                        const datasets = [{
                            label: key,
                            data: chartData.map(item => item[key]),
                            borderColor: getRandomColor(),
                            backgroundColor: 'rgba(67, 97, 238, 0.2)',
                            borderWidth: 2,
                            pointRadius: 5,
                            pointHoverRadius: 7,
                            tension: 0.1
                        }];
                        
                        const ctx = canvas.getContext('2d');
                        const chart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: labels,
                                datasets: datasets
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    title: {
                                        display: true,
                                        text: `${key} Trend Analysis`,
                                        font: {
                                            size: 16,
                                            weight: 'bold'
                                        }
                                    },
                                    tooltip: {
                                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                        callbacks: {
                                            label: function(context) {
                                                return `${context.dataset.label}: ${context.raw}`;
                                            }
                                        }
                                    },
                                    legend: {
                                        labels: {
                                            font: {
                                                size: 12
                                            }
                                        }
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: false,
                                        title: {
                                            display: true,
                                            text: key,
                                            font: {
                                                weight: 'bold'
                                            }
                                        },
                                        grid: {
                                            color: 'rgba(0, 0, 0, 0.05)'
                                        }
                                    },
                                    x: {
                                        title: {
                                            display: true,
                                            text: 'Date',
                                            font: {
                                                weight: 'bold'
                                            }
                                        },
                                        grid: {
                                            color: 'rgba(0, 0, 0, 0.05)'
                                        }
                                    }
                                }
                            }
                        });
                        
                        chartInstances.push(chart);
                    });
                })
                .catch(error => {
                    loader.classList.add("hidden");
                    console.error("Error fetching or processing data:", error);
                    graphsContainer.innerHTML = "<p class='text-center' style='color: #dc3545; font-weight: bold;'>Error loading charts. Please try again.</p>";
                });
            });
            
            // Helper functions
            function populateCheckboxCards(optionsArray) {
                // Clear the container
                checkboxCardsContainer.innerHTML = "";
                
                // Add filtered options
                optionsArray.forEach(opt => {
                    const card = document.createElement("div");
                    card.className = "metric-card";
                    if (selectedValues.includes(opt)) {
                        card.classList.add("selected");
                    }
                    
                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.value = opt;
                    checkbox.checked = selectedValues.includes(opt);
                    checkbox.id = `checkbox-${opt.replace(/\s+/g, '-').replace(/[^a-zA-Z0-9-]/g, '')}`;
                    
                    const label = document.createElement("label");
                    label.textContent = opt;
                    label.setAttribute("for", checkbox.id);
                    
                    card.appendChild(checkbox);
                    card.appendChild(label);
                    
                    // Add event listener for the checkbox itself
                    checkbox.addEventListener("click", function(e) {
                        // Stop the event from bubbling up to the card
                        e.stopPropagation();
                        
                        const isChecked = this.checked;
                        
                        // Check if we're trying to select more than 5
                        if (isChecked && selectedValues.length >= 5) {
                            alert("You can select up to 5 health metrics only.");
                            this.checked = false;
                            return;
                        }
                        
                        const card = this.closest('.metric-card');
                        if (isChecked) {
                            card.classList.add("selected");
                            if (!selectedValues.includes(this.value)) {
                                selectedValues.push(this.value);
                            }
                        } else {
                            card.classList.remove("selected");
                            selectedValues = selectedValues.filter(val => val !== this.value);
                        }
                        
                        updateSelectedOptions();
                        updateSelectedCount();
                    });
                    
                    // Add event listener for the card
                    card.addEventListener("click", function(e) {
                        // Only handle clicks on the card itself or label, not the checkbox
                        if (e.target.tagName === "INPUT") {
                            return; // Let the checkbox handler deal with it
                        }
                        
                        // Prevent default behavior if clicking on label
                        if (e.target.tagName === "LABEL") {
                            e.preventDefault();
                        }
                        
                        const checkbox = this.querySelector('input[type="checkbox"]');
                        const isChecked = !checkbox.checked;
                        
                        // Check if we're trying to select more than 5
                        if (isChecked && selectedValues.length >= 5) {
                            alert("You can select up to 5 health metrics only.");
                            return;
                        }
                        
                        checkbox.checked = isChecked;
                        if (isChecked) {
                            this.classList.add("selected");
                            if (!selectedValues.includes(checkbox.value)) {
                                selectedValues.push(checkbox.value);
                            }
                        } else {
                            this.classList.remove("selected");
                            selectedValues = selectedValues.filter(val => val !== checkbox.value);
                        }
                        
                        updateSelectedOptions();
                        updateSelectedCount();
                    });
                    
                    checkboxCardsContainer.appendChild(card);
                });
                
                if (optionsArray.length === 0) {
                    const noResults = document.createElement("p");
                    noResults.textContent = "No matching metrics found";
                    noResults.style.padding = "10px";
                    noResults.style.color = "#666";
                    checkboxCardsContainer.appendChild(noResults);
                }
            }
            
            function updateSelectedOptions() {
                // Update the selected options display
                selectedOptionsContainer.innerHTML = "";
                selectedValues.forEach(value => {
                    const tag = document.createElement("div");
                    tag.className = "selected-tag";
                    tag.innerHTML = `${value} <span class="remove-tag" data-value="${value}">&times;</span>`;
                    selectedOptionsContainer.appendChild(tag);
                });
                
                // Add event listeners to the remove buttons
                document.querySelectorAll(".remove-tag").forEach(button => {
                    button.addEventListener("click", function() {
                        const valueToRemove = this.getAttribute("data-value");
                        // Find and uncheck the corresponding checkbox
                        const checkbox = document.querySelector(`input[value="${valueToRemove}"]`);
                        if (checkbox) {
                            checkbox.checked = false;
                            checkbox.closest('.metric-card').classList.remove("selected");
                        }
                        
                        // Remove from selectedValues
                        selectedValues = selectedValues.filter(val => val !== valueToRemove);
                        
                        // Update displays
                        updateSelectedOptions();
                        updateSelectedCount();
                    });
                });
                
                // Enable/disable generate button based on selection count
                generateBtn.disabled = selectedValues.length === 0 || selectedValues.length > 5;
            }
            
            function updateSelectedCount() {
                selectedCountDisplay.textContent = `Selected: ${selectedValues.length}/5`;
                
                // Add warning class if we're at the limit
                if (selectedValues.length === 5) {
                    selectedCountDisplay.classList.add("warning");
                } else {
                    selectedCountDisplay.classList.remove("warning");
                }
            }
            
            function getCSRFToken() {
                return document.cookie.split('; ').find(row => row.startsWith('csrftoken='))?.split('=')[1] || '';
            }
            
            function getRandomColor() {
                const colors = [
                    '#4361ee', '#3a0ca3', '#4895ef', '#4cc9f0', '#560bad',
                    '#f72585', '#7209b7', '#3f37c9', '#4361ee', '#4895ef'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
        });
    </script>
</body>
</html>